package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"html/template"
	"io"
	"os"
	"strings"
)

const outputTemplateSrc = `package {{.Package}}
// generated by gin routegen {{$verbose := .Verbose}}
// do not edit this file directly.
// edit the route spec file and re-run gin routegen.
import gin "{{.Import}}"

// {{.Func}} is an auto-generated function which
// will create routes based on a given route spec.
func {{.Func}}(g *gin.Engine) {
{{range .Routes}}{{if $verbose}}
  // {{.SourceSpec}}
{{end}}
  g.{{.Method}}("{{.RouteSpec}}", {{.Handler}}){{end}}
}
`

var outputTemplate = template.Must(template.New("routegen").Parse(outputTemplateSrc))

type route struct {
	SourceSpec string
	Method     string
	RouteSpec  string
	Handler    string
}

type outputData struct {
	Package string
	Func    string
	Import  string
	Verbose bool
	Routes  []route
}

var (
	packageName   string
	funcName      string
	ginImport     string
	inputPath     string
	outputPath    string
	verboseOutput bool
)

func main() {
	pn := flag.String("p", "routes", "package name")
	fn := flag.String("f", "AutoRoute", "function name")
	gn := flag.String("g", "github.com/gin-gonic/gin", "Gin library import")
	in := flag.String("i", "routes.txt", "routes file")
	on := flag.String("o", "routes.go", "generated source path")
	vo := flag.Bool("v", false, "Verbose output")
	flag.Parse()

	packageName = *pn
	funcName = *fn
	ginImport = *gn
	inputPath = *in
	outputPath = *on
	verboseOutput = *vo

	data := outputData{
		Package: packageName,
		Func:    funcName,
		Import:  ginImport,
		Verbose: verboseOutput,
	}

	routeSrc, err := os.OpenFile(inputPath, os.O_RDONLY, 0644)

	defer routeSrc.Close()

	if err != nil {
		fmt.Fprintf(os.Stderr, "Unable to open %s: %s\n", outputPath, err)
		os.Exit(100)
	}

	var routeGen io.Writer

	if outputPath == "-" {
		routeGen = os.Stdout
	} else {
		routeGen, err = os.OpenFile(outputPath, os.O_WRONLY|os.O_TRUNC|os.O_CREATE, 0644)
		defer routeGen.(*os.File).Close()
		if err != nil {
			fmt.Fprintf(os.Stderr, "Unable to open %s: %s\n", outputPath, err)
			os.Exit(100)
		}
	}

	inRoutes := bufio.NewScanner(routeSrc)
	inRoutes.Split(bufio.ScanLines)

	for inRoutes.Scan() {
		routeSpec := inRoutes.Text()

		// Skip comments and empty lines
		if strings.HasPrefix(routeSpec, "//") || strings.Trim(routeSpec, "\t ") == "" {
			continue
		}

		routeBuffer := bytes.NewBufferString(routeSpec)
		routeScanner := bufio.NewScanner(routeBuffer)
		routeScanner.Split(bufio.ScanWords)

		routeScanner.Scan()
		method := routeScanner.Text()
		routeScanner.Scan()
		pathSpec := routeScanner.Text()
		routeScanner.Scan()
		handler := routeScanner.Text()

		// Handle resource pseudo-methods
		if method == "RESOURCE" {
			resourceRoutes := []route{
				route{
					SourceSpec: routeSpec,
					Method:     "GET",
					RouteSpec:  pathSpec,
					Handler:    handler + "{}.Index",
				},

				route{
					SourceSpec: routeSpec,
					Method:     "GET",
					RouteSpec:  pathSpec + "/view/:id",
					Handler:    handler + "{}.Show",
				},

				route{
					SourceSpec: routeSpec,
					Method:     "GET",
					RouteSpec:  pathSpec + "/new",
					Handler:    handler + "{}.New",
				},

				route{
					SourceSpec: routeSpec,
					Method:     "GET",
					RouteSpec:  pathSpec + "/edit/:id",
					Handler:    handler + "{}.Edit",
				},

				route{
					SourceSpec: routeSpec,
					Method:     "PUT",
					RouteSpec:  pathSpec,
					Handler:    handler + "{}.Create",
				},

				route{
					SourceSpec: routeSpec,
					Method:     "POST",
					RouteSpec:  pathSpec,
					Handler:    handler + "{}.Create",
				},

				route{
					SourceSpec: routeSpec,
					Method:     "PATCH",
					RouteSpec:  pathSpec + "/update/:id",
					Handler:    handler + "{}.Update",
				},

				route{
					SourceSpec: routeSpec,
					Method:     "POST",
					RouteSpec:  pathSpec + "/update/:id",
					Handler:    handler + "{}.Update",
				},

				route{
					SourceSpec: routeSpec,
					Method:     "DELETE",
					RouteSpec:  pathSpec + "/delete/:id",
					Handler:    handler + "{}.Delete",
				},

				route{
					SourceSpec: routeSpec,
					Method:     "POST",
					RouteSpec:  pathSpec + "/delete/:id",
					Handler:    handler + "{}.Delete",
				},
			}

			data.Routes = append(data.Routes, resourceRoutes...)

		} else {
			data.Routes = append(data.Routes, route{
				SourceSpec: routeSpec,
				Method:     method,
				RouteSpec:  pathSpec,
				Handler:    handler,
			})
		}

	}

	err = outputTemplate.Execute(routeGen, data)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Unable to generate router: %s\n", err)
		os.Exit(110)
	}

}
